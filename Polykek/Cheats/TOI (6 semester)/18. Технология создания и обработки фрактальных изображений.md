#Polykek/cheats/TOI #фракталы

## Введение

Многие из объектов природы и КГ обладают свойством самоподобия (self – similar), означающим, что изображения выглядят «одинаково» при любом масштабировании: имеет одну и ту же степень сложности. Одни кривые (изображения) в точности самоподобны (exactly self – similar): какое бы сильное увеличение мы не делали, увеличенное изображение выглядит в точности как оригинал, за исключением, быть может, поворота и сдвига. Другие кривые являются только статистически самоподобными (statistically self – similar): здесь неправильности и изгибы кривой при любом масштабировании не изменяются только «в среднем». В природе существуют примеры статистического самоподобия: классические примеры – береговая линия, ветки деревьев, кровеносная система. В 70-е годы Бенуа Мандельброт из Йельского университета обобщил и популяризовал исследования природы самоподобия (см. Mandelbrot, B. “Fractals: Form, Chance and Dimension”, 1977 и “The Fractal Geometry of Nature”,1983). Он назвал различные формы самоподобных кривых ФРАКТАЛАМИ (fractals, от лат. fractus – «фрагментированный», «дробной размерности»). Определение фрактала, данное Мандельбротом, звучит так: "Фракталом называется структура, состоящая из частей, которые в каком-то смысле подобны целому".

Если на каждом шаге не только уменьшать основной мотив, но также смещать и поворачивать его, можно получить более интересные и реалистически выглядящие образования, например, лист папоротника или даже целые их заросли. А можно построить весьма правдоподобный фрактальный рельеф местности и покрыть её очень симпатичным лесом. В ЗD Studio Мах, например, для генерации деревьев используется фрактальный алгоритм. И это не исключение: большинство текстур местности в современных компьютерных играх представляют фракталы. Горы, лес и облака на картинке - фракталы.

Файлы фрактальных изображений имеют расширение fif. Обычно 2 файлы в формате fif получаются несколько меньше файлов в формате jpg но бывает и наоборот. Самое интересное начинается, если рассматривать картинки со все большим увеличением. Файлы в формате jpg почти сразу демонстрируют свою дискретную природу – появляется пресловутая лесенка. А вот fif файлы, как и положено фракталам, с ростом увеличения показывают все новую степень детализации структуры, сохраняя эстетику изображения.

## История появления фракталов

Первые идеи фрактальной геометрии возникли в 19 веке. Кантор с помощью простой рекурсивной(повторяющейся) процедуры превратил линию в набор несвязанных точек (так называемая Пыль Кантора). Он браллинию и удалял центральную треть и после этого повторял то же самое с оставшимися отрезками.

Пеано нарисовал особый вид линии (рисунок №2). Для ее рисования Пеано использовал следующий алгоритм. На первом шаге он брал прямую линию и заменял ее на 9 отрезков длинной в 3 раза меньшей, чем длинна исходной линии (Часть 1 и 2 рисунка 2). Далее он делал то же самое с каждым 3 отрезком получившейся линии. И так до бесконечности. Ее уникальность в том, что она заполняет всю плоскость.

Кривая Пеано и пыль Кантора выходили за рамки обычных геометрических объектов. Они не имели четкой размерности. Пыль Кантора строилась на основании одномерной прямой, но состояла из точек (размерность 0). А кривая Пеано строилась на основании одномерной линии, а в результате получалась плоскость.

Математик Ф. Хаусдорф (Felix Hausdorff) ввел понятие дробных размерностей на основе анализа простых самоподобных объектов типа прямых, квадратов и кубов. Предположим, что мы разбиваем линию единичной длины на N равных отрезков; отношение длины каждого из отрезков к длине исходной прямой будет r=1/N. Проделав то же самое с квадратом (разделив его на N одинаковых квадратов), тогда соотношение сторон каждого малого квадрата к исходному есть r=1/N1/2. Аналогично для куба: r=1/N1/3 и т.д. Просматривается закономерность, на основании которой было сформулировано определение: объект обладает размерностью D, если при разделении его на N равных частей каждая часть будет иметь сторону, меньшую, чем сторона исходного объекта в r=1/N1/D раз, т.е. D=log(N) / log(1/r). Таким образом, в нашем случае для кривой Коха т.к. при переходе от одного поколения к следующему из каждого отрезка создается N=4 отрезка, а их длины получаются из длин отрезков предыдущего поколения при умножении их на r=1/3, то D=log(4) / log(3)=1,26 !

## Свойства фракталов

1. Прежде всего фрактал – это не линия или поверхность в виде привычных уравнений. Фракталы выражаются не в первичных геометрических формах, а в алгоритмах, которые трансформируются в геометрические формы с помощью компьютерной программы. 
2. Характер большинства фрактальных алгоритмов преимущественно рекурсивный. 
3. Теоретически глубина рекурсии фрактала бесконечна. 
4. Независимо от природы и метода построения у всех фракталов есть одно важное общее свойство, характеризующее степень их раздробленности и предельные свойства. Это – фрактальная размерность. Согласно идее Мандельброта ее можно определить подсчетом числа элементов N, принадлежащих фрактальному множеству, при различных разрешениях $\delta$ – минимальных линейных размерах элементов. 
5. Размерность фрактала может быть дробной

## Геометрические фракталы. Кривые Коха

Фракталы этого класса самые наглядные. В двухмерном случае их получают с помощью некоторой ломаной (или поверхности в трехмерном случае), называемой генератором. За один шаг алгоритма каждый из отрезков, составляющих ломаную, заменяется на ломаную-генератор, в соответствующем масштабе. В результате бесконечного повторения этой процедуры, получается геометрический фрактал. Очень сложные кривые можно получать рекурсивно посредством многократного «усложнения» простой кривой. Простейший пример такого рода – кривая Коха (Koch curve), открытая в 1904 г. шведским математиком Хельгом фон Кохом. Эта кривая примечательна тем, что образует бесконечно длинную линию внутри области конечной площади. Обозначим K0, K1, K2 … - последовательные поколения кривой Коха. Форма нулевого поколения K0 – просто горизонтальная прямая единичной длины. Для создания K1 нужно разделить прямую K0 на 3 равные части и заменить среднюю из них треугольным «зубцом» со сторонами длиной 1/3. Длина всей линии составит 4/3. Кривая второго поколения K2 образована путем построения зубца на каждом из 4 отрезков линии K1 Для создания кривой Коха Kn+1 из Kn необходимо разделить каждый отрезок 5 кривой Kn на 3 равные части и заменить среднюю часть зубцом в форме равностороннего треугольника.

В течение этого процесса длина каждого отрезка увеличивается в 4/3 раза, следовательно, общая длина кривой в 4/3 раза больше длины кривой предыдущего поколения. Тогда общая длина кривой Ki составит (4/3)i . При стремлении i к бесконечности длина кривой становится бесконечной.

Строго самоподобной является только предельная кривая K , однако, эффект самоподобия может быть аппроксимирован с помощью компьютерной графики: нужно сделать n настолько большим, чтобы даже при максимальном увеличении наименьшие отрезки прямых были меньше расстояния между пикселями. Снежинка Коха образована из 3 соединенных вместе кривых Коха. Периметр Si поколения втрое больше длины простой кривой Коха и, следовательно, равен 3*(4/3)i , что, разумеется, неограниченно растет с ростом i. Однако доказано, что площадь, ограниченная снежинкой Коха, растет довольно медленно и в пределе S=8/5*S0, т.е. эта площадь – ограничена.

## Алгоритм рисования кривых и снежинок Коха

Можно взглянуть на кривые Коха иначе: каждое поколение состоит из 4 версий предыдущего поколения. Назовем n – порядком кривой Kn, тогда 6 говорят, что кривая Коха n-го порядка состоит из 4 кривых Коха (n-1) порядка. Рисование кривой Коха (псевдокод):

```
if (n=0) 
	Draw (line); 
else { 
	Draw(Kn-1); 
	Turn_left 60’; 
	Draw(Kn-1);  
	Turn_right 120’; 
	Draw(Kn-1); 
	Turn_left 60’; 
	Draw(Kn-1); 
}  

void DrawKoch(double dir, double len, int n) {  
	dirRad=0.0174533*dir; 
	if(n==0) 
		LineTo(len*cos(dirRad),len*sin(dirRad);  
	else { 
		n--; 
		len/=3; 
		DrawKoch(dir,len,n); 
		dir+=60;  
		DrawKoch(dir,len,n); 
		dir-=120; 
		DrawKoch(dir,len,n); 
		dir+=60;  
		DrawKoch(dir,len,n); 
	} 
}
```

## Метод L –систем

L-системы были предложены в качестве математической модели развития растений биологом Аристидом Линденмайером. L в названии – это первая буква его фамилии. L-системы являются параллельными переписывающими системами. Метод L-систем (L-Systems) основан на простом наборе инструкций черепашьей графики, задаваемых через командную строку.

Черепаха интерпретирует каждый символ командной строки как команду на выполнение определенной операции.

Задается набор допустимых команд:

1) ‘F’ (forward(1,1)) – переместиться в перед на расстояние 1 в текущем направлении 
2) ‘+’ (turn (A)) – поворот направо (по часовой стрелке) на заданный угол A градусов 
3) ‘-’ (turn (–A)) – поворот налево (против часовой стрелки) на угол A градусов.

Также необходимо определить инструкции создания строк (stringproduction rules), обозначаемые символом ‘→’.

Пример: ‘F’ →’F-F++F-F’, где знак ‘→’ обозначает, что каждый встретившийся символ ‘F’ заменяется указанной группой символов.

Исходная строка называется атомом (в примере это ‘F’); если угол А=60’, то на 1 стадии генерируется строка 1-гопоколения S1=’F-F++F-F’(кривая Коха K1);

строка 2-го поколения: S2=’F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F’ ... (черепаха нарисует кривую Коха K2) и т.д.

Подпрограмма produceString() итеративно формирует строку очередного поколения, причем каждая строка повторно поступает в одну и ту же функцию, чтобы создать объект более высокого порядка.

![[Pasted image 20240611095710.png]]

В процесс генерации строк можно ввести дополнительные инструкции: использовать другие символы, например, X и Y, и задавать им определенные инструкции.

**Пример:** Построение фрактальных «кривых дракона» (dragon curves) можно задать набором инструкций:

![[Pasted image 20240611095734.png]]

Используя в качестве атома ‘FX’, получим строку 
S1= ‘FX+YF+’ – дракон 1 порядка; 
S2=’FX+YF++-FX-YF+’ и т.д. 

При этом черепаха игнорирует символы ‘X’ и ‘Y’, в то время как символы ‘F’, ‘+’, и ‘- ‘ интерпретируются как и прежде. Так, черепаха рисует дракона 1 порядка, игнорируя символы ‘X’ и ‘Y’ в строке ‘FX+YF+’ и реагирует только на строку ‘F+F+’, поэтому кривая будет состоять только из 2 отрезков прямой, образующих «колено» с углом А (=90’). Для дракона 2 порядка черепаха реагирует на строку ‘F+F++- F-F+’ или эквивалентную ей ‘F+F+F-F+’ и т.д.

Приведем данные для наиболее известных классов кривых: для каждой кривой задаются 5 ключевых компонентов в порядке: атом, F-строка, X-строка, Y-строка, угол поворота в градусах (словом nil обозначена пустая строка).

![[Pasted image 20240611100131.png]]

## Разрешение ветвления и фрактальные деревья

Свойство ветвления позволит черепахе делать ветвеподобные рисунки. Средство для реализации: символ, предписывающий черепахе «запомнить текущее положение» для дальнейшего использования ‘\[‘ и символ для возвращение черепахи в это положение ‘]’.

‘\[‘: saveTurtle() – записать текущее состояние черепахи. ‘]’: restoreTurtle() – установить состояние черепахи в ранее записанное значение.

Под состоянием черепахи понимается пара {CP,CD}, где CP(Current Position) – координаты положения черепахи; CD (Current Direction) – текущее направление. Состояния черепахи удобно хранить в стеке, поэтому создадим «черепаший стек» (turtle stack), который будет выглядеть: (1,3,5,22),45 ← вершина черепашьего стека (0,7,-2,7),30 и т.д. Если в строке встретится символ ‘\[’, то текущее состояние проталкивается в стек для дальнейшего использования; если встретился символ ‘]’,то из стека выталкивается верхнее значение, и состояние черепахи устанавливается равным вытолкнутому значению.

Фрактальные деревья: (fractal trees) напоминают настоящие деревья, «кусты» имеют несколько «ветвей» и сама ветвь подобна уменьшенной копии целого 10 дерева. Если это самоподобие сохраняется до произвольной глубины, то такой рисунок становится фракталом.

Куст, изображенный на рисунке, создан на базе атома ‘F’ угла 22’ и F строки вида: 
`F → ‘FF-\[-F+F+F]+\[+F-F-F]’.`

Здесь «ветвь» ‘F’ на каждом шаге рекурсии замещается 3 элементами: 
1) Длинной прямой линией ‘FF’ – ствол. 
2) Левой ветвью, состоящей из 3 коротких прямых. 
3) Правой ветвью, состоящей из 3 коротких прямых.

Черепаха возвращается в точку, помеченную «вернуться сюда», 2 раза, когда в строке встречается команда ‘]’. Эта точка возврата является стартовой точкой следующей генерации.

![[Pasted image 20240611100438.png]]

## Системы итерируемых функций

Экспериментальный копир: Еще один способ приближения к бесконечности – многократно применять к данному изображению какое-либо преобразование и смотреть, что получится. Эта идея была развита Барнсли (M.Barnsley).

Берем исходный образ I0 и помещаем его в специальный «фотокопир», создающий изображение I1, являющееся совмещением нескольких уменьшенных копий I0. Затем берем изображение I1 и посылаем его обратно в копир, чтобы получить изображение I2. Повторяя этот процесс бесконечно, мы получим последовательность изображений I0,I1,I2 …,которая называется орбитой I0.

Рассмотрим пример «S-копира»: он вкладывает друг в друга 3 уменьшенные версии любого изображения, которое подается на вход.

![[Pasted image 20240611100538.png]]

На рисунке приведено несколько первых итераций, которые производит S-копир. Видно, что они сходятся к треугольнику Серпинского. При каждой итерации отдельный компонент F становится вдвое меньше, а количество компонентов утраивается. При больших N IN почти не зависит от формы буквы F, а зависит только от свойств самого копира.

Работу копира можно представить, как результат действия 3 линз, каждая из которых уменьшает подающееся на нее изображение в 2 раза и переносит его в новое положение. Масштабирование и смещение легко осуществляются при помощи аффинных преобразований, т.е. каждая линза выполняет собственное аффинное преобразование T1(P), T2(P)и Т3(P) для каждой точки P исходного изображения.

В примере 
T1:` X’=0.5*X , Y’=0.5*Y`; (левая нижняя буква) 
T2: `X’=0.5*X+0.5, Y’=0.5*Y;` (правая нижняя буква) 
T3: `X’=0.5*X+0.25, Y’=0.5*Y-0.5` (верхняя буква)

В общем случае копир содержит N линз, каждая из которых осуществляет свое аффинное преобразование и затем добавляет свое изображение к выходному. Барнсли назвал этот набор аффинных преобразований «системой итерируемых функций».

Определение: Система итерируемых функций (iterated function system – IFS) – набор из N аффинных преобразований Ti, i=1..N. Метод "Систем Итерируемых Функций" появился в середине 80-х годов как простое средство получения фрактальных структур. При использовании в качестве I0 изолированной точки каждая итерация будет представлять собой множество точек. Тогда если система IFS состоит из N аффинных преобразований, то первая итерация I1 состоит из N точек, I2 – из N2 точек, I3 – из N3 точек и т.д.

Пример: достаточно хорошо известна «папоротниковая» IFS, состоящая из 4 аффинных преобразований:

X' = 0 Y' = 0.16*Y 
X' = 0.2*X +0.23*Y Y' = -0.26*X+0.22*Y + 1.6 13 
X' = -0.15*X + 0.26*Y Y' = 0.28*X -+0.24*Y + 0.44 
X' = 0.85*X - 0.04*Y Y' = 0.04*X + 0.85*Y + 1.6

Заметим, что первое преобразование производит масштабирование в xнаправлении с 0 множителем, формируя вертикальный стебель папоротника. Последняя матрица осуществляет малый поворот и затем незначительно уменьшает обрабатываемое изображение (примерно до 85%), поэтому копии уменьшаются очень медленно.

## Фрактальное сжатие изображений

Путем анализа заданного изображения может быть получена система IFS, для которого это изображение является аттрактором. Поскольку запись представления системы IFS занимает во много раз меньше места, чем сохраненное изображение, то этот подход вызвал огромный интерес в области сжатия изображений. Вопросы фрактального сжатия изображений сложны тем, что для большинства изображений неясно даже, существует ли для них вообще базисная система IFS.

