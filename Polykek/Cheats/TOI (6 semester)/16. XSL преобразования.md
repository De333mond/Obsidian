#Polykek/cheats/TOI #XSL-XML 

## Способы XSL преобразования XML – документа

Преобразование XML-документа может выполняться двумя способами: 
• преобразователем (парсером) браузера на локальной машине или 
• на сервере, например, средствами языка PHP, а браузеру отправляться HTML код.

### Локальное XSL преобразование

Для реализации первого способа на локальной машине необходимы два файла: 
• XML – документ 
• Файл с таблицей стилей XSL

В файле XML-документа должна содержаться ссылка на стилевой файл. Загрузка XML – документа приводит к генерации кода в соответствии с XSLT инструкциями и отображению полученного кода. 

### Серверное XSL преобразование

Необходимы три файла: 
• XML - документ 
• XSL - таблица 
• PHP- скрипт

XML – документ и XSL файл хранятся на сервере. 
XML – документ не содержит ссылку на стилевой файл XSL.
PHP- скрипт загружает XML – документ, XSL – таблицe и запускает преобразование.

### Подключение и использование библиотеки php_xsl.dll

Для реализации этих процедур необходимо подключение и использование библиотеки php_xsl.dll (листинг 1).

### Древовидная структура XML – документа

XSL преобразователь (парсер) моделирует XML – документ как дерево, образованное семью видами узлов:
- Корень 
- Элементы 
- Текст 
- Атрибуты 
- Процессуальные инструкции 
- Пространства имен 
- Комментарии

### Шаблоны преобразования
XSL преобразование выполняется с помощью шаблонов в XSL файле.

```
<xsl:template match="/">
	<html> <body>
	 <table border="l">
		 <tr>
			 <th>Название</th> <th> Жанр </th>
		 </tr>
		 <tr>
			 <td><xsl:value-of select="gerichten/gericht/Name"/></td>
			 <td><xsl:value-of select="gerichten/gericht/art"/></td>
		 </tr>
	 </table>
	</body> </html>
</xsl:template>
```

Шаблон создается тегом xsl:template. Атрибут match служит для связывания шаблона с элементом (узлом) в XML – документе. 
В данном случае match=”/” со значением «/» задает корневой узел XML – документа. 
Парсер (браузер) просматривает XML – документ и ищет в нем элемент, заданный атрибутом (корень). Как только элемент найден в браузер (выходной документ) передаются данные из таблицы стилей и исходного XML – документа. Из таблицы стилей берется часть, следующая за началом шаблона. Для передачи в выходной поток еще и содержимого XML – документа в примере 2 применяется тег xsl:value-of с атрибутом select.

xsl:value-of – выбирает значение и копирует результат в выходной документ. 
select – атрибут тега xsl:value-of определяет, какое именно значение выбирается.

#### Рекурсивный обход дерева XML – документа. Xsl:apply-templates

Чтобы после обнаружения элемента соответствующего шаблону продолжить рекурсивный просмотр узлов XML – документа в XSLT существует элемент xsl:apply-templates (листинг 2). 

Этот элемент дает указание парсеру сравнивать каждый дочерний узел исходного найденного узла с другими шаблонами в таблице стилей и, если соответствие обнаружено, выводить шаблон для соответствующего узла в выходной документ.

Использование элемента цикла xsl:for-each. 
Для повтора части шаблона для всех элементов используется элемент xsl:for-each (листинг 3).

Сортировка данных в выходном документе. Xsl:sort
Для сортировки используется элемент xsl:sort.

![[Pasted image 20240611093001.png]]

#### Для фильтрации используется нотация
<xsl:for-each select="movies/movie\[title='Бриллиантовая рука']">
![[Pasted image 20240611093046.png]]

### Работа с атрибутами. Xsl:apply-templates

Для обращения к атрибутам используется символ @. Но атрибуты не являются дочерними узлами содержащих их элементов. Поэтому при движении по дереву парсер не видит атрибуты. Их нужно обрабатывать, явно прописывая их в значении атрибута select элемента xsl:apply-templates.

Добавление XML – данных в качестве атрибутов в выходной документ. Xsl:attribute Для этой задачи используется элемент xsl:attribute
```
<A>
	<xsl:attribute name="HREF">
	<xsl:value-of select="Name"/>.jpg</xsl:attribute>
	 <xsl:value-of select="Name"/>
</A>
```

Для решения этой задачи используется атрибут mode. Должны быть написаны шаблоны с различными атрибутами mode. Например, для дублирования данных требуется два шаблона: и Кроме того, должен быть обеспечен проход дерева XML – документа два раза с указанием соответствующего атрибута mode (листинг 8).

Например с помощью рекурсивного обхода элементом xsl:applytemplates:
```
<xsl:apply-templates select="gerichten" mode="text"/>

<xsl:apply-templates select="gerichten" mode="bild"/>
```


